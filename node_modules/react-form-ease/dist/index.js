var mr = Object.defineProperty;
var gr = (f, r, a) => r in f ? mr(f, r, { enumerable: !0, configurable: !0, writable: !0, value: a }) : f[r] = a;
var E = (f, r, a) => (gr(f, typeof r != "symbol" ? r + "" : r, a), a);
import Fe, { useState as re } from "react";
var te = { exports: {} }, L = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ve;
function pr() {
  if (Ve)
    return L;
  Ve = 1;
  var f = Fe, r = Symbol.for("react.element"), a = Symbol.for("react.fragment"), v = Object.prototype.hasOwnProperty, S = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, j = { key: !0, ref: !0, __self: !0, __source: !0 };
  function b(_, d, w) {
    var R, C = {}, F = null, I = null;
    w !== void 0 && (F = "" + w), d.key !== void 0 && (F = "" + d.key), d.ref !== void 0 && (I = d.ref);
    for (R in d)
      v.call(d, R) && !j.hasOwnProperty(R) && (C[R] = d[R]);
    if (_ && _.defaultProps)
      for (R in d = _.defaultProps, d)
        C[R] === void 0 && (C[R] = d[R]);
    return { $$typeof: r, type: _, key: F, ref: I, props: C, _owner: S.current };
  }
  return L.Fragment = a, L.jsx = b, L.jsxs = b, L;
}
var Y = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ae;
function br() {
  return Ae || (Ae = 1, process.env.NODE_ENV !== "production" && function() {
    var f = Fe, r = Symbol.for("react.element"), a = Symbol.for("react.portal"), v = Symbol.for("react.fragment"), S = Symbol.for("react.strict_mode"), j = Symbol.for("react.profiler"), b = Symbol.for("react.provider"), _ = Symbol.for("react.context"), d = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), R = Symbol.for("react.suspense_list"), C = Symbol.for("react.memo"), F = Symbol.for("react.lazy"), I = Symbol.for("react.offscreen"), B = Symbol.iterator, ie = "@@iterator";
    function p(e) {
      if (e === null || typeof e != "object")
        return null;
      var t = B && e[B] || e[ie];
      return typeof t == "function" ? t : null;
    }
    var m = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function u(e) {
      {
        for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
          i[n - 1] = arguments[n];
        T("error", e, i);
      }
    }
    function T(e, t, i) {
      {
        var n = m.ReactDebugCurrentFrame, l = n.getStackAddendum();
        l !== "" && (t += "%s", i = i.concat([l]));
        var c = i.map(function(o) {
          return String(o);
        });
        c.unshift("Warning: " + t), Function.prototype.apply.call(console[e], console, c);
      }
    }
    var P = !1, ne = !1, Le = !1, Ye = !1, We = !1, se;
    se = Symbol.for("react.module.reference");
    function qe(e) {
      return !!(typeof e == "string" || typeof e == "function" || e === v || e === j || We || e === S || e === w || e === R || Ye || e === I || P || ne || Le || typeof e == "object" && e !== null && (e.$$typeof === F || e.$$typeof === C || e.$$typeof === b || e.$$typeof === _ || e.$$typeof === d || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      e.$$typeof === se || e.getModuleId !== void 0));
    }
    function Me(e, t, i) {
      var n = e.displayName;
      if (n)
        return n;
      var l = t.displayName || t.name || "";
      return l !== "" ? i + "(" + l + ")" : i;
    }
    function ue(e) {
      return e.displayName || "Context";
    }
    function V(e) {
      if (e == null)
        return null;
      if (typeof e.tag == "number" && u("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof e == "function")
        return e.displayName || e.name || null;
      if (typeof e == "string")
        return e;
      switch (e) {
        case v:
          return "Fragment";
        case a:
          return "Portal";
        case j:
          return "Profiler";
        case S:
          return "StrictMode";
        case w:
          return "Suspense";
        case R:
          return "SuspenseList";
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case _:
            var t = e;
            return ue(t) + ".Consumer";
          case b:
            var i = e;
            return ue(i._context) + ".Provider";
          case d:
            return Me(e, e.render, "ForwardRef");
          case C:
            var n = e.displayName || null;
            return n !== null ? n : V(e.type) || "Memo";
          case F: {
            var l = e, c = l._payload, o = l._init;
            try {
              return V(o(c));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var x = Object.assign, D = 0, oe, le, fe, ce, ve, he, de;
    function me() {
    }
    me.__reactDisabledLog = !0;
    function Ue() {
      {
        if (D === 0) {
          oe = console.log, le = console.info, fe = console.warn, ce = console.error, ve = console.group, he = console.groupCollapsed, de = console.groupEnd;
          var e = {
            configurable: !0,
            enumerable: !0,
            value: me,
            writable: !0
          };
          Object.defineProperties(console, {
            info: e,
            log: e,
            warn: e,
            error: e,
            group: e,
            groupCollapsed: e,
            groupEnd: e
          });
        }
        D++;
      }
    }
    function ze() {
      {
        if (D--, D === 0) {
          var e = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: x({}, e, {
              value: oe
            }),
            info: x({}, e, {
              value: le
            }),
            warn: x({}, e, {
              value: fe
            }),
            error: x({}, e, {
              value: ce
            }),
            group: x({}, e, {
              value: ve
            }),
            groupCollapsed: x({}, e, {
              value: he
            }),
            groupEnd: x({}, e, {
              value: de
            })
          });
        }
        D < 0 && u("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Z = m.ReactCurrentDispatcher, J;
    function W(e, t, i) {
      {
        if (J === void 0)
          try {
            throw Error();
          } catch (l) {
            var n = l.stack.trim().match(/\n( *(at )?)/);
            J = n && n[1] || "";
          }
        return `
` + J + e;
      }
    }
    var G = !1, q;
    {
      var Be = typeof WeakMap == "function" ? WeakMap : Map;
      q = new Be();
    }
    function ge(e, t) {
      if (!e || G)
        return "";
      {
        var i = q.get(e);
        if (i !== void 0)
          return i;
      }
      var n;
      G = !0;
      var l = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var c;
      c = Z.current, Z.current = null, Ue();
      try {
        if (t) {
          var o = function() {
            throw Error();
          };
          if (Object.defineProperty(o.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(o, []);
            } catch (A) {
              n = A;
            }
            Reflect.construct(e, [], o);
          } else {
            try {
              o.call();
            } catch (A) {
              n = A;
            }
            e.call(o.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (A) {
            n = A;
          }
          e();
        }
      } catch (A) {
        if (A && n && typeof A.stack == "string") {
          for (var s = A.stack.split(`
`), y = n.stack.split(`
`), h = s.length - 1, g = y.length - 1; h >= 1 && g >= 0 && s[h] !== y[g]; )
            g--;
          for (; h >= 1 && g >= 0; h--, g--)
            if (s[h] !== y[g]) {
              if (h !== 1 || g !== 1)
                do
                  if (h--, g--, g < 0 || s[h] !== y[g]) {
                    var O = `
` + s[h].replace(" at new ", " at ");
                    return e.displayName && O.includes("<anonymous>") && (O = O.replace("<anonymous>", e.displayName)), typeof e == "function" && q.set(e, O), O;
                  }
                while (h >= 1 && g >= 0);
              break;
            }
        }
      } finally {
        G = !1, Z.current = c, ze(), Error.prepareStackTrace = l;
      }
      var k = e ? e.displayName || e.name : "", Pe = k ? W(k) : "";
      return typeof e == "function" && q.set(e, Pe), Pe;
    }
    function Ze(e, t, i) {
      return ge(e, !1);
    }
    function Je(e) {
      var t = e.prototype;
      return !!(t && t.isReactComponent);
    }
    function M(e, t, i) {
      if (e == null)
        return "";
      if (typeof e == "function")
        return ge(e, Je(e));
      if (typeof e == "string")
        return W(e);
      switch (e) {
        case w:
          return W("Suspense");
        case R:
          return W("SuspenseList");
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case d:
            return Ze(e.render);
          case C:
            return M(e.type, t, i);
          case F: {
            var n = e, l = n._payload, c = n._init;
            try {
              return M(c(l), t, i);
            } catch {
            }
          }
        }
      return "";
    }
    var U = Object.prototype.hasOwnProperty, pe = {}, be = m.ReactDebugCurrentFrame;
    function z(e) {
      if (e) {
        var t = e._owner, i = M(e.type, e._source, t ? t.type : null);
        be.setExtraStackFrame(i);
      } else
        be.setExtraStackFrame(null);
    }
    function Ge(e, t, i, n, l) {
      {
        var c = Function.call.bind(U);
        for (var o in e)
          if (c(e, o)) {
            var s = void 0;
            try {
              if (typeof e[o] != "function") {
                var y = Error((n || "React class") + ": " + i + " type `" + o + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof e[o] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw y.name = "Invariant Violation", y;
              }
              s = e[o](t, o, n, i, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (h) {
              s = h;
            }
            s && !(s instanceof Error) && (z(l), u("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", n || "React class", i, o, typeof s), z(null)), s instanceof Error && !(s.message in pe) && (pe[s.message] = !0, z(l), u("Failed %s type: %s", i, s.message), z(null));
          }
      }
    }
    var Ke = Array.isArray;
    function K(e) {
      return Ke(e);
    }
    function He(e) {
      {
        var t = typeof Symbol == "function" && Symbol.toStringTag, i = t && e[Symbol.toStringTag] || e.constructor.name || "Object";
        return i;
      }
    }
    function Xe(e) {
      try {
        return ye(e), !1;
      } catch {
        return !0;
      }
    }
    function ye(e) {
      return "" + e;
    }
    function Re(e) {
      if (Xe(e))
        return u("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", He(e)), ye(e);
    }
    var N = m.ReactCurrentOwner, Qe = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ee, _e, H;
    H = {};
    function er(e) {
      if (U.call(e, "ref")) {
        var t = Object.getOwnPropertyDescriptor(e, "ref").get;
        if (t && t.isReactWarning)
          return !1;
      }
      return e.ref !== void 0;
    }
    function rr(e) {
      if (U.call(e, "key")) {
        var t = Object.getOwnPropertyDescriptor(e, "key").get;
        if (t && t.isReactWarning)
          return !1;
      }
      return e.key !== void 0;
    }
    function tr(e, t) {
      if (typeof e.ref == "string" && N.current && t && N.current.stateNode !== t) {
        var i = V(N.current.type);
        H[i] || (u('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', V(N.current.type), e.ref), H[i] = !0);
      }
    }
    function ar(e, t) {
      {
        var i = function() {
          Ee || (Ee = !0, u("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", t));
        };
        i.isReactWarning = !0, Object.defineProperty(e, "key", {
          get: i,
          configurable: !0
        });
      }
    }
    function ir(e, t) {
      {
        var i = function() {
          _e || (_e = !0, u("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", t));
        };
        i.isReactWarning = !0, Object.defineProperty(e, "ref", {
          get: i,
          configurable: !0
        });
      }
    }
    var nr = function(e, t, i, n, l, c, o) {
      var s = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: r,
        // Built-in properties that belong on the element
        type: e,
        key: t,
        ref: i,
        props: o,
        // Record the component responsible for creating this element.
        _owner: c
      };
      return s._store = {}, Object.defineProperty(s._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(s, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: n
      }), Object.defineProperty(s, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: l
      }), Object.freeze && (Object.freeze(s.props), Object.freeze(s)), s;
    };
    function sr(e, t, i, n, l) {
      {
        var c, o = {}, s = null, y = null;
        i !== void 0 && (Re(i), s = "" + i), rr(t) && (Re(t.key), s = "" + t.key), er(t) && (y = t.ref, tr(t, l));
        for (c in t)
          U.call(t, c) && !Qe.hasOwnProperty(c) && (o[c] = t[c]);
        if (e && e.defaultProps) {
          var h = e.defaultProps;
          for (c in h)
            o[c] === void 0 && (o[c] = h[c]);
        }
        if (s || y) {
          var g = typeof e == "function" ? e.displayName || e.name || "Unknown" : e;
          s && ar(o, g), y && ir(o, g);
        }
        return nr(e, s, y, l, n, N.current, o);
      }
    }
    var X = m.ReactCurrentOwner, we = m.ReactDebugCurrentFrame;
    function $(e) {
      if (e) {
        var t = e._owner, i = M(e.type, e._source, t ? t.type : null);
        we.setExtraStackFrame(i);
      } else
        we.setExtraStackFrame(null);
    }
    var Q;
    Q = !1;
    function ee(e) {
      return typeof e == "object" && e !== null && e.$$typeof === r;
    }
    function Oe() {
      {
        if (X.current) {
          var e = V(X.current.type);
          if (e)
            return `

Check the render method of \`` + e + "`.";
        }
        return "";
      }
    }
    function ur(e) {
      {
        if (e !== void 0) {
          var t = e.fileName.replace(/^.*[\\\/]/, ""), i = e.lineNumber;
          return `

Check your code at ` + t + ":" + i + ".";
        }
        return "";
      }
    }
    var Te = {};
    function or(e) {
      {
        var t = Oe();
        if (!t) {
          var i = typeof e == "string" ? e : e.displayName || e.name;
          i && (t = `

Check the top-level render call using <` + i + ">.");
        }
        return t;
      }
    }
    function Se(e, t) {
      {
        if (!e._store || e._store.validated || e.key != null)
          return;
        e._store.validated = !0;
        var i = or(t);
        if (Te[i])
          return;
        Te[i] = !0;
        var n = "";
        e && e._owner && e._owner !== X.current && (n = " It was passed a child from " + V(e._owner.type) + "."), $(e), u('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', i, n), $(null);
      }
    }
    function je(e, t) {
      {
        if (typeof e != "object")
          return;
        if (K(e))
          for (var i = 0; i < e.length; i++) {
            var n = e[i];
            ee(n) && Se(n, t);
          }
        else if (ee(e))
          e._store && (e._store.validated = !0);
        else if (e) {
          var l = p(e);
          if (typeof l == "function" && l !== e.entries)
            for (var c = l.call(e), o; !(o = c.next()).done; )
              ee(o.value) && Se(o.value, t);
        }
      }
    }
    function lr(e) {
      {
        var t = e.type;
        if (t == null || typeof t == "string")
          return;
        var i;
        if (typeof t == "function")
          i = t.propTypes;
        else if (typeof t == "object" && (t.$$typeof === d || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        t.$$typeof === C))
          i = t.propTypes;
        else
          return;
        if (i) {
          var n = V(t);
          Ge(i, e.props, "prop", n, e);
        } else if (t.PropTypes !== void 0 && !Q) {
          Q = !0;
          var l = V(t);
          u("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", l || "Unknown");
        }
        typeof t.getDefaultProps == "function" && !t.getDefaultProps.isReactClassApproved && u("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function fr(e) {
      {
        for (var t = Object.keys(e.props), i = 0; i < t.length; i++) {
          var n = t[i];
          if (n !== "children" && n !== "key") {
            $(e), u("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", n), $(null);
            break;
          }
        }
        e.ref !== null && ($(e), u("Invalid attribute `ref` supplied to `React.Fragment`."), $(null));
      }
    }
    function Ce(e, t, i, n, l, c) {
      {
        var o = qe(e);
        if (!o) {
          var s = "";
          (e === void 0 || typeof e == "object" && e !== null && Object.keys(e).length === 0) && (s += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var y = ur(l);
          y ? s += y : s += Oe();
          var h;
          e === null ? h = "null" : K(e) ? h = "array" : e !== void 0 && e.$$typeof === r ? (h = "<" + (V(e.type) || "Unknown") + " />", s = " Did you accidentally export a JSX literal instead of a component?") : h = typeof e, u("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", h, s);
        }
        var g = sr(e, t, i, l, c);
        if (g == null)
          return g;
        if (o) {
          var O = t.children;
          if (O !== void 0)
            if (n)
              if (K(O)) {
                for (var k = 0; k < O.length; k++)
                  je(O[k], e);
                Object.freeze && Object.freeze(O);
              } else
                u("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              je(O, e);
        }
        return e === v ? fr(g) : lr(g), g;
      }
    }
    function cr(e, t, i) {
      return Ce(e, t, i, !0);
    }
    function vr(e, t, i) {
      return Ce(e, t, i, !1);
    }
    var hr = vr, dr = cr;
    Y.Fragment = v, Y.jsx = hr, Y.jsxs = dr;
  }()), Y;
}
process.env.NODE_ENV === "production" ? te.exports = pr() : te.exports = br();
var yr = te.exports;
function jr(f) {
  const { form: r, onSubmit: a, resetAfterSubmit: v = !1, children: S, ...j } = f, b = async (_) => {
    _.preventDefault(), !(r.validateForm && !r.validateForm()) && (r.validateFormAsync && !await r.validateFormAsync() || (r.setIsLoading && r.setIsLoading(!0), a && await a(), r.setIsLoading && r.setIsLoading(!1), v && r.resetForm && r.resetForm()));
  };
  return /* @__PURE__ */ yr.jsx("form", { ...j, onSubmit: b, noValidate: !0, children: S });
}
function Cr(f) {
  const { data: r, validations: a, asyncValidations: v } = f, [S, j] = re(!1), [b, _] = re(r), [d, w] = re();
  return {
    formData: b,
    updateForm: (p) => {
      _({ ...b, ...p }), Object.keys(p).forEach((m) => w({ ...d, [m]: void 0 }));
    },
    isLoading: S,
    setIsLoading: j,
    resetForm: () => _(r),
    validateForm: () => {
      if (!a || Object.keys(a).length == 0)
        return !0;
      let p = !0;
      const m = {};
      for (const u of Object.keys(a)) {
        const T = a[u], P = T(b[u], b);
        P && (p = !1, m[u] = P);
      }
      return w(m), p;
    },
    validateFormAsync: async () => {
      if (!v || Object.keys(v).length == 0)
        return !0;
      j(!0);
      let p = !0;
      const m = {};
      for await (const u of Object.keys(v)) {
        const T = v[u];
        let P = null;
        try {
          P = await T(b[u], b);
        } catch {
          P = `An exception occurred while the validator [${u}] was running`;
        }
        P && (p = !1, m[u] = P);
      }
      return w(m), j(!1), p;
    },
    errors: d,
    validateInput: (p) => {
      if (!a || Object.keys(a).length == 0)
        return !0;
      const m = a[p];
      if (!m)
        return !0;
      const u = m(b[p], b), T = { ...d };
      return u && (T[p] = u), w(T), !u;
    },
    validateInputAsync: async (p) => {
      if (!v || Object.keys(v).length == 0)
        return !0;
      const m = v[p];
      if (!m)
        return !0;
      let u = null;
      try {
        u = await m(b[p], b);
      } catch {
        u = `An exception occurred while the validator [${p}] was running`;
      }
      const T = { ...d };
      return u && (T[p] = u), w(T), !u;
    }
  };
}
let Rr = class xe {
  constructor() {
    E(this, "message");
    E(this, "value");
  }
  static fromValue(r) {
    const a = new xe();
    return a.value = r, a;
  }
  /**
   * 
   * @returns Error message if there is one
   */
  validate() {
    return this.message;
  }
  /**
   * Validates if the value is not null or undefined.
   * @param message The custom error message to display if the value is null or undefined.
   * @returns The current Validator instance.
   */
  required(r = "Required field") {
    return (this.value === null || this.value === void 0) && (this.message = r), this;
  }
  /**
   * Validates if the value is true. Null or undefined values will be ignored
   * @param message The custom error message to display if the value is false.
   * @returns The current Validator instance.
   */
  isTrue(r = "Required field to be true") {
    return this.value === null || this.value === void 0 ? this : (this.value === !1 && (this.message = r), this);
  }
  /**
   * Validates if the value is false. Null or undefined values will be ignored
   * @param message The custom error message to display if the value is true.
   * @returns The current Validator instance.
   */
  isFalse(r = "Required field to be false") {
    return this.value === null || this.value === void 0 ? this : (this.value === !0 && (this.message = r), this);
  }
};
function Pr(f) {
  return Rr.fromValue(f);
}
let Er = class $e {
  constructor() {
    E(this, "message");
    E(this, "value");
  }
  static fromValue(r) {
    const a = new $e();
    return r && (a.value = new Date(r)), r === void 0 && (a.value = void 0), r === null && (a.value = null), a;
  }
  /**
   *
   * @returns Error message if there is one
   */
  validate() {
    return this.message;
  }
  /**
   * Validates if the value is not null or undefined.
   * @param message The custom error message to display if the value is null or undefined.
   * @returns The current Validator instance.
   */
  required(r = "Required field") {
    return this.value || (this.message = r), this;
  }
  /**
   * Validates if the date is valid. Null or undefine values will be ignored, please use required() to validate them.
   * @param message The custom error message to display if the date is invalid.
   * @returns The current DateValidator instance.
   */
  isValid(r = "Invalid date") {
    return this.value ? (isNaN(this.value.getTime()) && (this.message = r), this) : this;
  }
  /**
   * Validates if the year of the date is a leap year. Null or undefine values will be ignored, please use required() to validate them.
   * @param message The custom error message to display if the year is not a leap year.
   * @returns The current DateValidator instance.
   */
  leapYear(r = "Date must be leap year") {
    if (!this.value)
      return this;
    const a = this.value.getFullYear();
    return a % 4 === 0 && a % 100 !== 0 || a % 400 === 0 || (this.message = r), this;
  }
  /**
   * Validates if the date is greater than a specified compareDate. Null or undefine values will be ignored, please use required() to validate them.
   * @param compareDate The date to compare against.
   * @param message The custom error message to display if the date is not greater than compareDate.
   * @returns The current DateValidator instance.
   */
  greaterThan(r, a = `Date must be greater than ${r}`) {
    return this.value ? (this.value <= r && (this.message = a), this) : this;
  }
  /**
   * Validates if the date is less than a specified compareDate. Null or undefine values will be ignored, please use required() to validate them.
   * @param compareDate The date to compare against.
   * @param message The custom error message to display if the date is not less than compareDate.
   * @returns The current DateValidator instance.
   */
  lessThan(r, a = `Date must be less than ${r}`) {
    return this.value ? (this.value >= r && (this.message = a), this) : this;
  }
  /**
   * Validates if the date is within a specified range. Null or undefine values will be ignored, please use required() to validate them.
   * @param startDate The start date of the range.
   * @param endDate The end date of the range.
   * @param message The custom error message to display if the date is not within the specified range.
   * @returns The current DateValidator instance.
   */
  range(r, a, v = `Date must be between ${r} and ${a}`) {
    return this.value ? ((this.value < r || this.value > a) && (this.message = v), this) : this;
  }
};
function Vr(f) {
  return Er.fromValue(f);
}
let _r = class ke {
  constructor() {
    E(this, "message");
    E(this, "value");
  }
  static fromValue(r) {
    const a = new ke();
    return a.value = r, a;
  }
  /**
   *
   * @returns Error message if there is one
   */
  validate() {
    return this.message;
  }
  /**
   * Validates if the value is not null or undefined.
   * @param message The custom error message to display if the value is null or undefined.
   * @returns The current Validator instance.
   */
  required(r = "Required field") {
    return (this.value === null || this.value === void 0) && (this.message = r), this;
  }
  /**
   * Validates if the value is an integer. Null or undefine values will be ignored, please use required() to validate them.
   * @param message The custom error message to display if the value is not an integer.
   * @returns The current NumberValidator instance.
   */
  integer(r = "Value must be an integer") {
    return this.value === null || this.value === void 0 ? this : ((isNaN(this.value) || !Number.isInteger(this.value)) && (this.message = r), this);
  }
  /**
   * Validates if the value is a decimal number. Null or undefine values will be ignored, please use required() to validate them.
   * @param message The custom error message to display if the value is not a decimal number.
   * @returns The current NumberValidator instance.
   */
  decimal(r = "Value must be a decimal") {
    return this.value === null || this.value === void 0 ? this : ((isNaN(this.value) || Number.isInteger(this.value)) && (this.message = r), this);
  }
  /**
   * Validates if the value is a positive number. Null or undefine values will be ignored, please use required() to validate them.
   * @param message The custom error message to display if the value is not positive.
   * @returns The current NumberValidator instance.
   */
  positive(r = "Value must be positive") {
    return this.value === null || this.value === void 0 ? this : (this.value < 0 && (this.message = r), this);
  }
  /**
   * Validates if the value is a negative number. Null or undefine values will be ignored, please use required() to validate them.
   * @param message The custom error message to display if the value is not negative.
   * @returns The current NumberValidator instance.
   */
  negative(r = "Value must be negative") {
    return this.value === null || this.value === void 0 ? this : (this.value >= 0 && (this.message = r), this);
  }
  /**
   * Validates if the value is within a specified range. Null or undefine values will be ignored, please use required() to validate them.
   * @param min The minimum value of the range.
   * @param max The maximum value of the range.
   * @param message The custom error message to display if the value is not within the specified range.
   * @returns The current NumberValidator instance.
   */
  range(r, a, v = `Value must be between ${r} and ${a}`) {
    return this.value === null || this.value === void 0 ? this : ((this.value < r || this.value > a) && (this.message = v), this);
  }
  /**
   * Validates if the value is greater than a specified minimum value. Null or undefine values will be ignored, please use required() to validate them.
   * @param min The minimum value to compare against.
   * @param message The custom error message to display if the value is not greater than the specified minimum value.
   * @returns The current NumberValidator instance.
   */
  min(r, a = `Value must be more than ${r}`) {
    return this.value === null || this.value === void 0 ? this : (this.value < r && (this.message = a), this);
  }
  /**
   * Validates if the value is less than a specified maximum value. Null or undefine values will be ignored, please use required() to validate them.
   * @param max The maximum value to compare against.
   * @param message The custom error message to display if the value is not less than the specified maximum value.
   * @returns The current NumberValidator instance.
   */
  max(r, a = `Value must be less than ${r}`) {
    return this.value === null || this.value === void 0 ? this : (this.value > r && (this.message = a), this);
  }
};
function Ar(f) {
  return _r.fromValue(f);
}
let wr = class Ie {
  constructor() {
    E(this, "message");
    E(this, "value");
  }
  static fromValue(r) {
    const a = new Ie();
    return a.value = r, a;
  }
  /**
   *
   * @returns Error message if there is one
   */
  validate() {
    return this.message;
  }
  /**
   * Validates if the value is not null, undefined or an empty string.
   * @param message The custom error message to display if the value is null or undefined.
   * @returns The current Validator instance.
   */
  required(r = "Required field") {
    return this.value || (this.message = r), this;
  }
  /**
   * Validates if the string matches a specified regular expression. Null or undefine values will be ignored, please use required() to validate them.
   * @param regex The regular expression to match against.
   * @param message The custom error message to display if the string does not match the regular expression.
   * @returns The current StringValidator instance.
   */
  match(r, a = "Invalid value") {
    return this.value ? (r.test(this.value) || (this.message = a), this) : this;
  }
  /**
   * Validates if the string is a valid email address.
   * @param message The custom error message to display if the string is not a valid email address.
   * @returns The current StringValidator instance.
   */
  email(r = "Invalid email") {
    return this.match(/^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$/, r);
  }
  /**
   * Validates if the string is an integer (contains only digits).
   * @param message The custom error message to display if the string is not an integer.
   * @returns The current StringValidator instance.
   */
  integer(r = "Value must be a integer") {
    return this.match(/^\d+$/, r);
  }
  /**
   * Validates if the string contains only alphabetic characters (no digits or special characters).
   * @param message The custom error message to display if the string contains non-alphabetic characters.
   * @returns The current StringValidator instance.
   */
  alphabetic(r = "Value must be alphabetic") {
    return this.match(/^[A-Za-z]+$/, r);
  }
  /**
   * Validates if the string contains only alphanumeric characters (letters and digits).
   * @param message The custom error message to display if the string contains non-alphanumeric characters.
   * @returns The current StringValidator instance.
   */
  alphanumeric(r = "Value must be alphanumeric") {
    return this.match(/^[A-Za-z0-9]+$/, r);
  }
  /**
   * Validates if the string is a numeric value (integer or decimal).
   * @param message The custom error message to display if the string is not a numeric value.
   * @returns The current StringValidator instance.
   */
  numeric(r = "Value must be a number") {
    return this.match(/^[-+]?\d*\.?\d+$/, r);
  }
  /**
   * Validates if the string is a valid URL.
   * @param message The custom error message to display if the string is not a valid URL.
   * @returns The current StringValidator instance.
   */
  url(r = "Invalid URL") {
    if (!this.value)
      return this;
    try {
      new URL(this.value);
    } catch {
      this.message = r;
    }
    return this;
  }
  /**
   * Validates if the string has a specific length.
   * @param length The expected length of the string.
   * @param message The custom error message to display if the string length does not match the expected length.
   * @returns The current StringValidator instance.
   */
  length(r, a = `Value must contain exact ${r} chars`) {
    return this.value ? (this.value.length != r && (this.message = a), this) : this;
  }
  /**
   * Validates if the string has a minimum length.
   * @param minLength The minimum length the string must have.
   * @param message The custom error message to display if the string length is less than the minimum.
   * @returns The current StringValidator instance.
   */
  min(r, a = `Value must contain at least ${r} chars`) {
    return this.value ? (this.value.length < r && (this.message = a), this) : this;
  }
  /**
   * Validates if the string has a maximum length.
   * @param maxLength The maximum length the string can have.
   * @param message The custom error message to display if the string length exceeds the maximum.
   * @returns The current StringValidator instance.
   */
  max(r, a = `Value must contain less than ${r} chars`) {
    return this.value ? (this.value.length > r && (this.message = a), this) : this;
  }
  /**
   * Validates if the string contains only valid characters for a username.
   * @param message The custom error message to display if the string contains invalid characters.
   * @returns The current StringValidator instance.
   */
  username(r = "Value contains invalid characters") {
    return this.match(/^[A-Za-z0-9_]+$/, r);
  }
  /**
   * Validates if the string contains only valid characters for a name (letters and spaces).
   * @param message The custom error message to display if the string contains invalid characters.
   * @returns The current StringValidator instance.
   */
  name(r = "Value contains invalid characters") {
    return this.match(/^[A-Za-z\s]+$/, r);
  }
  /**
   * Validates if the string is a valid UUID (Universally Unique Identifier).
   * @param message The custom error message to display if the string is not a valid UUID.
   * @returns The current StringValidator instance.
   */
  uuid(r = "Invalid UUID") {
    return this.match(/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/, r);
  }
  /**
   * Validates if the string contains only lowercase characters.
   * @param message The custom error message to display if the string contains uppercase characters.
   * @returns The current StringValidator instance.
   */
  lowercase(r = "Value must be lowercase") {
    return this.value ? (this.value !== this.value.toLowerCase() && (this.message = r), this) : this;
  }
  /**
   * Validates if the string contains only uppercase characters.
   * @param message The custom error message to display if the string contains lowercase characters.
   * @returns The current StringValidator instance.
   */
  uppercase(r = "Value must be uppercase") {
    return this.value ? (this.value !== this.value.toUpperCase() && (this.message = r), this) : this;
  }
};
function Fr(f) {
  return wr.fromValue(f);
}
let Or = class De {
  constructor() {
    E(this, "message");
    E(this, "value");
  }
  static fromValue(r) {
    const a = new De();
    return a.value = r, a;
  }
  /**
   * @returns Error message if there is one
   */
  validate() {
    return this.message;
  }
  /**
   * Validates if the value is not null or undefined.
   * @param message The custom error message to display if the value is null or undefined.
   * @returns The current Validator instance.
   */
  required(r = "Required field") {
    return this.value || (this.message = r), this;
  }
  /**
   * Ensures that the array is not empty.
   *
   * @param message - Custom error message to display if the validation fails.
   * @returns This validator instance for chaining additional validations.
   */
  notEmpty(r = "Array must not be empty") {
    return this.value ? (this.value.length === 0 && (this.message = r), this) : this;
  }
  /**
   * Ensures that the array does not contain any duplicate elements.
   *
   * @param message - Custom error message to display if the validation fails.
   * @returns This validator instance for chaining additional validations.
   */
  hasNoDuplicates(r = "Array must not contain duplicates") {
    return this.value ? (new Set(this.value).size !== this.value.length && (this.message = r), this) : this;
  }
  /**
   * Ensures that the array has at least the specified minimum length.
   *
   * @param minLength - The minimum number of elements that the array should have.
   * @param message - Custom error message to display if the validation fails.
   * @returns This validator instance for chaining additional validations.
   */
  minLength(r, a = `Array must have at least ${r} elements`) {
    return this.value ? (this.value.length < r && (this.message = a), this) : this;
  }
  /**
   * Ensures that the array contains the specified element.
   *
   * @param element - The element that should be present in the array.
   * @param message - Custom error message to display if the validation fails.
   * @returns This validator instance for chaining additional validations.
   */
  contains(r, a = `Array must contain the element ${r}`) {
    return this.value ? (this.value.includes(r) || (this.message = a), this) : this;
  }
  /**
   * Ensures that all elements of the array match the specified predicate function.
   *
   * @param predicate - A function that takes an array element and returns a boolean.
   *                    All elements should satisfy this predicate function.
   * @param message - Custom error message to display if the validation fails.
   * @returns This validator instance for chaining additional validations.
   */
  allMatch(r, a = "All elements must match the predicate") {
    return this.value ? (this.value.every(r) || (this.message = a), this) : this;
  }
};
function xr(f) {
  return Or.fromValue(f);
}
class ae {
  constructor() {
    E(this, "message");
    E(this, "value");
  }
  static fromValue(r) {
    const a = new ae();
    return a.value = r, a;
  }
  /**
   *
   * @returns Error message if there is one
   */
  validate() {
    return this.message;
  }
  /**
   * Validates if the value is not null or undefined.
   * @param message The custom error message to display if the value is null or undefined.
   * @returns The current Validator instance.
   */
  required(r = "Required field") {
    return this.value || (this.message = r), this;
  }
  /**
   * Ensures that the object is not empty.
   * @param message - Custom error message to display if the validation fails.
   * @returns This validator instance for chaining additional validations.
   */
  notEmpty(r = "Object must not be empty") {
    return this.value ? (Object.keys(this.value).length == 0 && (this.message = r), this) : this;
  }
  /**
   * Ensures that the object contains all the specified required properties.
   * @param requiredProps - An array of property names that must be present in the object.
   * @param message - Custom error message to display if the validation fails.
   * @returns This validator instance for chaining additional validations.
   */
  hasRequiredProperties(r, a = `Object must contain ${r.join(",")}`) {
    return this.value ? (Ne(this.value, r) || (this.message = a), this) : this;
  }
  /**
   * Ensures that the object only contains allowed properties specified in the allowedProps array.
   * @param allowedProps - An array of property names that are allowed in the object.
   * @param message - Custom error message to display if the validation fails.
   * @returns This validator instance for chaining additional validations.
   */
  hasOnlyAllowedProperties(r, a = `Object only can contain ${r.join(",")}`) {
    if (!this.value)
      return this;
    for (const v in this.value)
      r.includes(v) || (this.message = a);
    return this;
  }
}
function $r(f) {
  return ae.fromValue(f);
}
function Ne(f, r) {
  for (const a of r)
    if (a.includes(".")) {
      const v = a.split("."), S = f[v[0]];
      if (!Ne(S, v.slice(1)))
        return !1;
    } else if (!f[a])
      return !1;
  return !0;
}
export {
  xr as array,
  Pr as boolean,
  Vr as date,
  jr as default,
  Ar as number,
  $r as object,
  Fr as string,
  Cr as useForm
};
//# sourceMappingURL=index.js.map
